<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Карта объектов</title>
    <style>
        html, body, #map {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #typeSelector {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            display: none;
        }
    </style>
</head>
<body>

<div id="map"></div>

<!-- Меню выбора типа -->
<div id="typeSelector">
    <select id="objectType">
        <option value="uzel">Узел</option>
        <option value="mufta">Муфта</option>
        <option value="shkaf">Шкаф</option>
        <option value="delitel">Оптический делитель</option>
        <option value="abonent">Абонент</option>
        <option value="opora">Опора</option>
        <option value="kolodec">Колодец</option>
        <option value="camera">Видеокамера</option>
        <option value="wifi">Wi-Fi тарелка</option>
    </select>

    <button id="addObjectBtn">Добавить</button>
</div>

<script src="https://api-maps.yandex.ru/2.1/?apikey=ВАШ_API_КЛЮЧ&lang=ru_RU"></script>
<script>
ymaps.ready(init);

let map;
let placemarks = {};
let lines = [];
let selectedPoint = null;

// Временное хранение для меню выбора типа
let pendingCoords = null;

// Пресеты для разных типов
const iconPresets = {
    uzel: "islands#blueIcon",
    mufta: "islands#darkGreenIcon",
    shkaf: "islands#brownIcon",
    delitel: "islands#violetIcon",
    abonent: "islands#darkOrangeIcon",
    opora: "islands#grayIcon",
    kolodec: "islands#blackIcon",
    camera: "islands#redIcon",
    wifi: "islands#yellowIcon"
};

function init() {
    map = new ymaps.Map("map", {
        center: [55.76, 37.64],
        zoom: 11
    });

    loadData();

    // Клик по карте → показать меню выбора типа объекта
    map.events.add("click", function(e) {
        pendingCoords = e.get("coords");

        const menu = document.getElementById("typeSelector");
        menu.style.display = "block";
    });

    // Создание объекта после выбора типа
    document.getElementById("addObjectBtn").onclick = () => {
        const type = document.getElementById("objectType").value;
        const id = Date.now();

        createPlacemark(id, type, pendingCoords, true);

        // скрываем меню
        document.getElementById("typeSelector").style.display = "none";
    };
}

// Создание объекта
function createPlacemark(pointId, type, coords, saveToServer=false) {
    let placemark = new ymaps.Placemark(coords, {}, {
        draggable: true,
        preset: iconPresets[type] || "islands#blueIcon"
    });

    map.geoObjects.add(placemark);
    placemarks[pointId] = { placemark, type };

    if (saveToServer) {
        fetch("/api/addPoint", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({id: pointId, type, x: coords[0], y: coords[1]})
        });
    }

    // ⬆ добавился тип объекта в БД

    placemark.events.add("dragend", () => {
        const newCoords = placemark.geometry.getCoordinates();

        fetch("/api/updatePoint", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({id: pointId, type, x: newCoords[0], y: newCoords[1]})
        });

        redrawLines();
    });

    // shift+клик – удаление
    placemark.events.add("click", async function(e) {
        const isShift = e.get("domEvent").originalEvent.shiftKey;

        if (isShift) {
            map.geoObjects.remove(placemark);

            lines = lines.filter(obj => {
                if (obj.a === pointId || obj.b === pointId) {
                    map.geoObjects.remove(obj.line);
                    return false;
                }
                return true;
            });

            fetch("/api/deletePoint", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({id: pointId})
            });

            delete placemarks[pointId];

            return;
        }

        // соединение
        if (!selectedPoint) {
            selectedPoint = pointId;
            placemark.options.set("preset", "islands#redIcon");
        } else if (selectedPoint !== pointId) {
            const line = new ymaps.Polyline([
                placemarks[selectedPoint].placemark.geometry.getCoordinates(),
                placemarks[pointId].placemark.geometry.getCoordinates()
            ], {}, {
                strokeWidth: 3
            });

            map.geoObjects.add(line);

            lines.push({ a: selectedPoint, b: pointId, line });

            fetch("/api/addLine", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({a: selectedPoint, b: pointId})
            });

            placemarks[selectedPoint].placemark.options.set("preset", iconPresets[placemarks[selectedPoint].type]);
            selectedPoint = null;
        }
    });
}

// Загрузка точек и линий
async function loadData() {
    const r = await fetch("/api/getPoints");
    const data = await r.json();

    data.points.forEach(p => {
        createPlacemark(p.id, p.type, [p.x, p.y], false);
    });

    data.lines.forEach(l => {
        const line = new ymaps.Polyline([
            placemarks[l.a].placemark.geometry.getCoordinates(),
            placemarks[l.b].placemark.geometry.getCoordinates()
        ], {}, { strokeWidth: 3 });

        map.geoObjects.add(line);
        lines.push({a: l.a, b: l.b, line});
    });
}

function redrawLines() {
    lines.forEach(obj => {
        obj.line.geometry.setCoordinates([
            placemarks[obj.a].placemark.geometry.getCoordinates(),
            placemarks[obj.b].placemark.geometry.getCoordinates()
        ]);
    });
}
</script>

</body>
</html>
